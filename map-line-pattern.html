<!doctype html>
<html lang="en">
    <head>
        <title>Restriction Markers - Line-Pattern vs</title> Approaches</title>
        <meta
            property="og:description"
            content="Interactive comparison of line-pattern, symbol-placement, and discrete symbol approaches for marking restricted roads."
        />
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link
            rel="stylesheet"
            href="https://unpkg.com/maplibre-gl@5.16.0/dist/maplibre-gl.css"
        />
        <script src="https://unpkg.com/maplibre-gl@5.16.0/dist/maplibre-gl.js"></script>
        <script src="https://unpkg.com/@turf/turf@7.0.0/turf.min.js"></script>
        <script src="config.js"></script>
        <style>
            * {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            }

            html,
            body,
            #map {
                height: 100%;
            }

            #control-panel {
                position: absolute;
                top: 10px;
                left: 10px;
                background: rgba(255, 255, 255, 0.95);
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
                font-size: 14px;
                max-width: 380px;
                z-index: 1;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            }

            #control-panel h2 {
                margin: 0 0 15px 0;
                font-size: 16px;
                font-weight: 600;
                color: #333;
            }

            .option-group {
                margin-bottom: 15px;
            }

            .option {
                padding: 12px;
                margin-bottom: 8px;
                background: #f5f5f5;
                border: 2px solid #ddd;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-weight: 500;
                color: #333;
            }

            .option:hover {
                background: #efefef;
                border-color: #999;
            }

            .option.active {
                background: #e3f2fd;
                border-color: #1976d2;
                color: #1565c0;
            }

            .details {
                margin-top: 15px;
                padding: 12px;
                background: #f9f9f9;
                border-left: 4px solid #1976d2;
                border-radius: 4px;
                font-size: 12px;
                line-height: 1.6;
                color: #555;
            }

            .details h3 {
                margin: 0 0 8px 0;
                font-size: 13px;
                font-weight: 600;
                color: #333;
            }

            .details ul {
                margin: 6px 0;
                padding-left: 18px;
            }

            .details li {
                margin: 3px 0;
            }

            .pro {
                color: #2e7d32;
                font-weight: 500;
            }

            .con {
                color: #c62828;
                font-weight: 500;
            }

            .divider {
                height: 1px;
                background: #ddd;
                margin: 15px 0;
            }

            .info-box {
                background: #fff3cd;
                border-left: 4px solid #ffc107;
                padding: 10px;
                border-radius: 4px;
                font-size: 12px;
                margin-top: 10px;
                color: #856404;
            }

            #zoom-info {
                position: absolute;
                bottom: 10px;
                right: 10px;
                background: rgba(255, 255, 255, 0.9);
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 12px;
                font-weight: 500;
                color: #333;
                z-index: 1;
            }
        </style>
    </head>
    <body>
        <div id="map"></div>

        <div id="control-panel">
            <h2>Restriction Markers</h2>
            <p style="margin: 0 0 15px 0; font-size: 13px; color: #666;">
                Click to switch between approaches:
            </p>

            <div class="option-group">
                <div id="option-line-pattern" class="option active">
                    üìä Line-Pattern (Repeating)
                </div>
                <div id="option-symbol-placement" class="option">
                    üìç Symbol-Placement: "line"
                </div>
                <div id="option-discrete-symbols" class="option">
                    üíé Discrete Symbols (50m)
                </div>
            </div>

            <div class="divider"></div>

            <div id="details" class="details">
                <h3>Line-Pattern Approach</h3>
                <p style="margin: 0 0 8px 0;">
                    Uses a repeating pattern image along the entire line.
                </p>
                <ul style="margin: 6px 0 8px 0;">
                    <li><span class="pro">‚úì Simplest implementation</span></li>
                    <li><span class="pro">‚úì Best performance</span></li>
                    <li><span class="con">‚úó No exact 50m spacing</span></li>
                    <li><span class="con">‚úó Pattern depends on image width</span></li>
                </ul>
                <div class="info-box">
                    üí° <strong>Best for:</strong> Visual indicators only, not metering
                </div>
            </div>
        </div>

        <div id="zoom-info">Zoom: <span id="zoom-level">15</span></div>

        <script>
            const map = new maplibregl.Map({
                container: "map",
                style: `https://api.tomtom.com/maps/orbis/assets/styles/*/style.json?key=${CONFIG.TOMTOM_API_KEY}&map=basic_street-light-driving&apiVersion=1`,
                center: [-122.486052, 37.830348],
                zoom: 15,
            });

            let currentMode = "line-pattern";

            const routeCoordinates = [
                [-122.48369693756104, 37.83381888486939],
                [-122.48348236083984, 37.83317489144141],
                [-122.48339653015138, 37.83270036637107],
                [-122.48356819152832, 37.832056363179625],
                [-122.48404026031496, 37.83114119107971],
                [-122.48404026031496, 37.83049717427869],
                [-122.48348236083984, 37.829920943955045],
                [-122.48356819152832, 37.82954808664175],
                [-122.48507022857666, 37.82944639795659],
                [-122.48610019683838, 37.82880236636284],
                [-122.48695850372314, 37.82931081282506],
                [-122.48700141906738, 37.83080223556934],
                [-122.48751640319824, 37.83168351665737],
                [-122.48803138732912, 37.832158048267786],
                [-122.48888969421387, 37.83297152392784],
                [-122.48987674713133, 37.83263257682617],
                [-122.49043464660643, 37.832937629287755],
                [-122.49125003814696, 37.832429207817725],
                [-122.49163627624512, 37.832564787218985],
                [-122.49223709106445, 37.83337825839438],
                [-122.49378204345702, 37.83368330777276],
            ];

            // Update zoom level display
            map.on("zoom", () => {
                document.getElementById("zoom-level").textContent = Math.round(map.getZoom() * 10) / 10;
            });

            map.on("load", () => {
                // Add route source
                map.addSource("route", {
                    type: "geojson",
                    data: {
                        type: "Feature",
                        properties: {},
                        geometry: {
                            type: "LineString",
                            coordinates: routeCoordinates,
                        },
                    },
                });

                // Base route layer (solid red)
                map.addLayer({
                    id: "route-base",
                    type: "line",
                    source: "route",
                    layout: {
                        "line-join": "round",
                        "line-cap": "round",
                    },
                    paint: {
                        "line-color": "#b61e1e",
                        "line-width": 2,
                    },
                });

                // Create pattern image (diamond shape)
                createPatternImage();
            });

            function createPatternImage() {
                // Create a canvas with repeating diamond pattern
                const canvas = document.createElement("canvas");
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext("2d");

                // Fill background transparent
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw diamond at specific position (left side of pattern)
                const diamondSize = 12;
                const x = canvas.width / 4;
                const y = canvas.height / 2;

                ctx.fillStyle = "#FF0000";
                ctx.strokeStyle = "#FFFFFF";
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(x, y - diamondSize);
                ctx.lineTo(x + diamondSize / 2, y);
                ctx.lineTo(x, y + diamondSize);
                ctx.lineTo(x - diamondSize / 2, y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Add to map as image
                const imageData = canvas.toDataURL("image/png");
                const img = new Image();
                img.onload = () => {
                    map.addImage("diamond-pattern", img);
                    console.log("Pattern image loaded");
                    showLinePattern();
                };
                img.src = imageData;
            }

            function showLinePattern() {
                // Remove any existing pattern/symbol layers
                const layersToRemove = [
                    "route-pattern",
                    "route-symbols",
                    "restriction-markers",
                ];
                layersToRemove.forEach((layerId) => {
                    if (map.getLayer(layerId)) map.removeLayer(layerId);
                });

                // Add line with pattern
                map.addLayer({
                    id: "route-pattern",
                    type: "line",
                    source: "route",
                    layout: {
                        "line-join": "round",
                        "line-cap": "round",
                    },
                    paint: {
                        "line-pattern": "diamond-pattern",
                        "line-width": 50,
                    },
                });

                updateDetails(
                    "line-pattern",
                    `
                    <h3>Line-Pattern Approach</h3>
                    <p style="margin: 0 0 8px 0;">
                        Uses a repeating pattern image along the entire line.
                    </p>
                    <ul style="margin: 6px 0;">
                        <li><span class="pro">‚úì Simplest implementation</span> - Single paint property</li>
                        <li><span class="pro">‚úì Best performance</span> - Native MapLibre rendering</li>
                        <li><span class="pro">‚úì No JavaScript needed</span></li>
                        <li><span class="con">‚úó No exact 50m spacing</span></li>
                        <li><span class="con">‚úó Pattern depends on image width</span></li>
                        <li><span class="con">‚úó Spacing inconsistent per segment</span></li>
                    </ul>
                    <div class="info-box">
                        üí° <strong>Best for:</strong> Visual indicators only, decorative patterns, not metering
                    </div>
                `,
                );
            }

            function showSymbolPlacement() {
                const layersToRemove = [
                    "route-pattern",
                    "route-symbols",
                    "restriction-markers",
                ];
                layersToRemove.forEach((layerId) => {
                    if (map.getLayer(layerId)) map.removeLayer(layerId);
                });

                // Add symbol layer that follows the line
                if (!map.getSource("route-for-symbols")) {
                    map.addSource("route-for-symbols", {
                        type: "geojson",
                        data: {
                            type: "Feature",
                            properties: {},
                            geometry: {
                                type: "LineString",
                                coordinates: routeCoordinates,
                            },
                        },
                    });
                }

                map.addLayer({
                    id: "route-symbols",
                    type: "symbol",
                    source: "route-for-symbols",
                    layout: {
                        "symbol-placement": "line",
                        "symbol-spacing": 250,
                        "icon-image": "diamond-pattern",
                        "icon-size": 1.5,
                        "icon-rotation-alignment": "map",
                        "icon-allow-overlap": false,
                    },
                });

                updateDetails(
                    "symbol-placement",
                    `
                    <h3>Symbol-Placement: "line" Approach</h3>
                    <p style="margin: 0 0 8px 0;">
                        Places symbols at regular intervals along the line.
                    </p>
                    <ul style="margin: 6px 0;">
                        <li><span class="pro">‚úì Built-in MapLibre feature</span></li>
                        <li><span class="pro">‚úì Symbols follow line direction</span></li>
                        <li><span class="pro">‚úì More control than patterns</span></li>
                        <li><span class="con">‚úó Spacing in screen pixels, not meters</span></li>
                        <li><span class="con">‚úó Spacing changes with zoom level</span></li>
                        <li><span class="con">‚úó Cannot achieve exact 50m intervals</span></li>
                    </ul>
                    <div class="info-box">
                        üí° <strong>Best for:</strong> Approximate spacing, visual flexibility, not metering
                    </div>
                `,
                );
            }

            function showDiscreteSymbols() {
                const layersToRemove = [
                    "route-pattern",
                    "route-symbols",
                    "restriction-markers",
                ];
                layersToRemove.forEach((layerId) => {
                    if (map.getLayer(layerId)) map.removeLayer(layerId);
                });

                // Calculate restriction markers at 50m intervals along the route
                const lineString = turf.lineString(routeCoordinates);
                const length = turf.length(lineString, { units: "meters" });
                console.log("Route length:", length, "meters");

                const markers = [];
                // Start at 25m to center first marker, then every 50m
                for (let distance = 25; distance < length; distance += 50) {
                    const point = turf.along(lineString, distance, {
                        units: "meters",
                    });

                    // Calculate bearing for marker rotation
                    const segment = turf.lineSlice(
                        turf.along(lineString, Math.max(0, distance - 1), {
                            units: "meters",
                        }),
                        turf.along(
                            lineString,
                            Math.min(length, distance + 1),
                            {
                                units: "meters",
                            },
                        ),
                        lineString,
                    );
                    const bearing = turf.bearing(
                        segment.geometry.coordinates[0],
                        segment.geometry.coordinates[
                            segment.geometry.coordinates.length - 1
                        ],
                    );

                    markers.push({
                        type: "Feature",
                        geometry: point.geometry,
                        properties: {
                            bearing: bearing,
                        },
                    });
                }

                // Add source for restriction markers
                if (map.getSource("restriction-markers")) {
                    map.removeSource("restriction-markers");
                }
                map.addSource("restriction-markers", {
                    type: "geojson",
                    data: {
                        type: "FeatureCollection",
                        features: markers,
                    },
                });
                console.log(
                    "Created",
                    markers.length,
                    "restriction markers",
                );

                // Add layer for restriction markers
                map.addLayer({
                    id: "restriction-markers",
                    type: "symbol",
                    source: "restriction-markers",
                    layout: {
                        "icon-image": "diamond-pattern",
                        "icon-rotate": ["get", "bearing"],
                        "icon-rotation-alignment": "map",
                        "icon-allow-overlap": true,
                        "icon-ignore-placement": true,
                        "icon-size": [
                            "interpolate",
                            ["exponential", 2],
                            ["zoom"],
                            10,
                            0.1,
                            15,
                            0.5,
                            18,
                            1.5,
                            20,
                            3,
                        ],
                    },
                });

                updateDetails(
                    "discrete",
                    `
                    <h3>Discrete Symbols (50m Intervals)</h3>
                    <p style="margin: 0 0 8px 0;">
                        Calculates exact positions using Turf.js, places individual markers.
                    </p>
                    <ul style="margin: 6px 0;">
                        <li><span class="pro">‚úì Exact 50m spacing</span></li>
                        <li><span class="pro">‚úì Precise marker placement</span></li>
                        <li><span class="pro">‚úì Can rotate each marker individually</span></li>
                        <li><span class="con">‚úó Requires runtime calculation</span></li>
                        <li><span class="con">‚úó Many symbols = more memory</span></li>
                        <li><span class="con">‚úó Not suitable for production tiles</span></li>
                    </ul>
                    <div class="info-box">
                        üí° <strong>Best for:</strong> Web prototyping, learning, not production with Unity
                    </div>
                `,
                );
            }

            function updateDetails(mode, html) {
                document.getElementById("details").innerHTML = html;
            }

            // Event listeners
            document.getElementById("option-line-pattern").addEventListener("click", () => {
                currentMode = "line-pattern";
                updateActiveOption("option-line-pattern");
                showLinePattern();
            });

            document.getElementById("option-symbol-placement").addEventListener("click", () => {
                currentMode = "symbol-placement";
                updateActiveOption("option-symbol-placement");
                showSymbolPlacement();
            });

            document.getElementById("option-discrete-symbols").addEventListener("click", () => {
                currentMode = "discrete";
                updateActiveOption("option-discrete-symbols");
                showDiscreteSymbols();
            });

            function updateActiveOption(activeId) {
                document.querySelectorAll(".option").forEach((el) => {
                    el.classList.remove("active");
                });
                document.getElementById(activeId).classList.add("active");
            }
        </script>
    </body>
</html>
